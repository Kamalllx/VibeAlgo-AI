# Generated Algorithm
# Generated by Algorithm Intelligence Suite
# Session: 20250601_190633_3
# Timestamp: 2025-06-01 19:07:18.064310

import sys
import heapq

def dijkstra(graph, start_node):
 """
 Description: The shortest path from a source node to all other nodes in the graph
 Time Complexity: O((V+E)logV)
 Space Complexity: O(V+E)
 """
 distances = {node: sys.maxsize for node in graph}
 distances[start_node] = 0
 priority_queue = [(0, start_node)]

 while priority_queue:
 current_distance, current_node = heapq.heappop(priority_queue)

 if current_distance > distances[current_node]:
 continue

 for neighbor, weight in graph[current_node].items():
 distance = current_distance + weight

 if distance < distances[neighbor]:
 distances[neighbor] = distance
 heapq.heappush(priority_queue, (distance, neighbor))

 return distances

# Test cases
graph1 = {
 'A': {'B': 1, 'C': 4},
 'B': {'A': 1, 'C': 2, 'D': 5},
 'C': {'A': 4, 'B': 2, 'D': 1},
 'D': {'B': 5, 'C': 1}
}
graph2 = {
 'A': {'B': 1, 'C': 3},
 'B': {'A': 1, 'C': 2},
 'C': {'A': 3, 'B': 2}
}

test_cases = [
 {"input": graph1, "expected": {'A': 0, 'B': 1, 'C': 3, 'D': 4}},
 {"input": graph2, "expected": {'A': 0, 'B': 1, 'C': 2}}
]

for test_case in test_cases:
 result = dijkstra(test_case["input"], 'A')
 print(f"Input: {test_case['input']}, Expected: {test_case['expected']}, Result: {result}")