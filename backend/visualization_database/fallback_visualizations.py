# backend/visualization_database/fallback_visualizations.py
#!/usr/bin/env python3
"""
Enhanced Fallback Visualization System
Provides visualizations when exact matches aren't found
"""

import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend
import matplotlib.pyplot as plt
import numpy as np
import os

def create_universal_algorithm_visualization(algorithm_name, description="Algorithm Visualization"):
    """Create a universal visualization for any algorithm"""
    
    try:
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        
        # 1. Generic algorithm steps
        steps = ['Input', 'Process', 'Compare', 'Update', 'Output']
        step_times = [1, 3, 2, 4, 1]
        colors = ['lightblue', 'orange', 'lightgreen', 'pink', 'lightcoral']
        
        bars = ax1.bar(steps, step_times, color=colors, alpha=0.8, edgecolor='black')
        ax1.set_title(f'{algorithm_name}: Generic Step Analysis', fontweight='bold')
        ax1.set_ylabel('Relative Time')
        
        # Add value labels
        for bar, time in zip(bars, step_times):
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width()/2., height + 0.05,
                   f'{time}', ha='center', va='bottom', fontweight='bold')
        
        # 2. Complexity comparison
        complexities = ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)', 'O(nÂ²)']
        values = [1, np.log2(1000), 1000, 1000*np.log2(1000), 1000**2]
        
        ax2.bar(complexities, values, color='skyblue', alpha=0.7)
        ax2.set_title('Time Complexity Comparison', fontweight='bold')
        ax2.set_ylabel('Operations (for n=1000)')
        ax2.set_yscale('log')
        ax2.tick_params(axis='x', rotation=45)
        
        # 3. Performance characteristics
        categories = ['Speed', 'Memory', 'Stability', 'Simplicity']
        # Generate reasonable scores
        scores = [np.random.randint(3, 5) for _ in categories]
        
        angles = np.linspace(0, 2*np.pi, len(categories), endpoint=False).tolist()
        scores += scores[:1]  # Complete the circle
        angles += angles[:1]
        
        ax3 = plt.subplot(2, 2, 3, projection='polar')
        ax3.plot(angles, scores, 'o-', linewidth=2, color='green')
        ax3.fill(angles, scores, alpha=0.25, color='green')
        ax3.set_xticks(angles[:-1])
        ax3.set_xticklabels(categories)
        ax3.set_ylim(0, 5)
        ax3.set_title(f'{algorithm_name}: Performance Profile', fontweight='bold', pad=20)
        
        # 4. Generic data flow
        ax4.text(0.5, 0.8, f'{algorithm_name}', ha='center', va='center', 
                transform=ax4.transAxes, fontsize=16, fontweight='bold',
                bbox=dict(boxstyle="round,pad=0.3", facecolor='lightblue'))
        
        ax4.text(0.5, 0.6, description, ha='center', va='center', 
                transform=ax4.transAxes, fontsize=12,
                bbox=dict(boxstyle="round,pad=0.3", facecolor='lightyellow'))
        
        # Draw arrows and process flow
        ax4.arrow(0.2, 0.4, 0.2, 0, head_width=0.05, head_length=0.05, 
                 fc='blue', ec='blue', transform=ax4.transAxes)
        ax4.text(0.1, 0.4, 'Input', ha='center', va='center', transform=ax4.transAxes)
        
        ax4.arrow(0.6, 0.4, 0.2, 0, head_width=0.05, head_length=0.05, 
                 fc='blue', ec='blue', transform=ax4.transAxes)
        ax4.text(0.9, 0.4, 'Output', ha='center', va='center', transform=ax4.transAxes)
        
        ax4.text(0.5, 0.4, 'Process', ha='center', va='center', transform=ax4.transAxes,
                bbox=dict(boxstyle="round,pad=0.2", facecolor='lightgreen'))
        
        ax4.text(0.5, 0.1, 'Generated by Algorithm Intelligence Suite\\nFallback Visualization System', 
                ha='center', va='center', transform=ax4.transAxes, fontsize=10, style='italic')
        
        ax4.set_xlim(0, 1)
        ax4.set_ylim(0, 1)
        ax4.axis('off')
        
        plt.tight_layout()
        
        filename = f'{algorithm_name.lower().replace(" ", "_")}_fallback.png'
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        plt.close()
        
        print(f"SUCCESS: Fallback visualization saved as {filename}")
        return filename
        
    except Exception as e:
        print(f"ERROR: Creating fallback visualization failed: {e}")
        return None

def create_sorting_algorithm_visualization():
    """Create a generic sorting visualization"""
    
    try:
        # Sample array and sorting steps
        arr = [64, 34, 25, 12, 22, 11, 90]
        sorted_arr = sorted(arr)
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))
        
        # Original array
        bars1 = ax1.bar(range(len(arr)), arr, color='lightcoral', alpha=0.7, edgecolor='black')
        ax1.set_title('Original Array', fontweight='bold')
        ax1.set_xlabel('Index')
        ax1.set_ylabel('Value')
        
        # Add value labels
        for i, bar in enumerate(bars1):
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width()/2., height + 1,
                   str(arr[i]), ha='center', va='bottom', fontweight='bold')
        
        # Sorted array
        bars2 = ax2.bar(range(len(sorted_arr)), sorted_arr, color='lightgreen', alpha=0.7, edgecolor='black')
        ax2.set_title('Sorted Array', fontweight='bold')
        ax2.set_xlabel('Index')
        ax2.set_ylabel('Value')
        
        # Add value labels
        for i, bar in enumerate(bars2):
            height = bar.get_height()
            ax2.text(bar.get_x() + bar.get_width()/2., height + 1,
                   str(sorted_arr[i]), ha='center', va='bottom', fontweight='bold')
        
        plt.tight_layout()
        
        filename = 'sorting_algorithm_fallback.png'
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        plt.close()
        
        print(f"SUCCESS: Sorting fallback visualization saved as {filename}")
        return filename
        
    except Exception as e:
        print(f"ERROR: Creating sorting visualization failed: {e}")
        return None

def create_search_algorithm_visualization():
    """Create a generic search visualization"""
    
    try:
        # Sample array and target
        arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
        target = 13
        target_index = arr.index(target)
        
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Create bars
        bars = ax.bar(range(len(arr)), arr, color='lightblue', alpha=0.7, edgecolor='black')
        
        # Highlight target
        bars[target_index].set_color('red')
        bars[target_index].set_alpha(0.9)
        
        # Add value labels
        for i, bar in enumerate(bars):
            height = bar.get_height()
            ax.text(bar.get_x() + bar.get_width()/2., height + 0.5,
                   str(arr[i]), ha='center', va='bottom', fontweight='bold')
            
            # Mark target
            if i == target_index:
                ax.text(bar.get_x() + bar.get_width()/2., height/2,
                       'TARGET\\nFOUND', ha='center', va='center', 
                       fontweight='bold', color='white')
        
        ax.set_title(f'Search Algorithm: Find {target} in Array', fontweight='bold')
        ax.set_xlabel('Array Index')
        ax.set_ylabel('Value')
        ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        filename = 'search_algorithm_fallback.png'
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        plt.close()
        
        print(f"SUCCESS: Search fallback visualization saved as {filename}")
        return filename
        
    except Exception as e:
        print(f"ERROR: Creating search visualization failed: {e}")
        return None

# Keyword mapping for intelligent fallback
FALLBACK_MAPPING = {
    'sort': create_sorting_algorithm_visualization,
    'search': create_search_algorithm_visualization,
    'binary': create_search_algorithm_visualization,
    'bubble': create_sorting_algorithm_visualization,
    'quick': create_sorting_algorithm_visualization,
    'merge': create_sorting_algorithm_visualization,
    'heap': create_sorting_algorithm_visualization,
    'linear': create_search_algorithm_visualization,
    'default': lambda: create_universal_algorithm_visualization("Generic Algorithm", "Universal algorithm visualization")
}

def get_best_fallback_visualization(query: str):
    """Get the best fallback visualization based on query"""
    
    query_lower = query.lower()
    
    for keyword, func in FALLBACK_MAPPING.items():
        if keyword in query_lower:
            return func()
    
    # Default fallback
    return FALLBACK_MAPPING['default']()
